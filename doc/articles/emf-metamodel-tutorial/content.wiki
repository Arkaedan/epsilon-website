=Create and instantiate your first EMF metamodel=
This article shows how to create and instantiate a simple flowchart metamodel with EMF.

==Prerequisites==
Eclipse Modeling distribution, Emfatic, Epsilon (see [[../../../download|download page]])

==Defining the flowchart metamodel in Emfatic==
There are several tools that allow you to define EMF metamodels including [[http://www.eclipse.org/modeling/emft/?project=ecoretools|EcoreTools]] (a graphical UML-like editor), the built-in tree-based EMF editor, and the [[http://wiki.eclipse.org/Emfatic|Emfatic]] textual notation. In this tutorial we will use the latter (Emfatic). 

But first we need to define the concepts of our language: `Flowchart` is the root concept of our language. A `Flowchart` contains two types of nodes: `Action` and `Decision` nodes. Each node has a `name`. A `Flowchart` also contains a number of `Transition`s that link a `source` to a `target` node. Each `Transition` also has a label. In Emfatic, this is specified as follows:

{{{
@namespace(uri="flowchart", prefix="flowchart")
package flowchart;

class Flowchart {
	val Node[*] nodes;
	val Transition[*] transitions;
}

abstract class Node {
	attr String name;
}

class Action extends Node {
	
}

class Decision extends Node {

}

class Transition {
	attr String label;
	ref Node source;
	ref Node transition;
}
}}}

===Attr vs. Ref vs. Val===
If you are familiar with Java, you will have noticed the Java-like syntax of Emfatic. What may seem strange is that some properties in classes are specified as `attr`, while others as `ref` and some as `val`. A short summary of the differences of `attr`, `ref` and `val` properties follows:

* `attr` (for attribute): is used to specify properties of simple types (primitive datatypes such as `String`, `Integer` and `Boolean`, and enumerations)
* `ref` (for reference): is used to specify '''non-containment''' references to other model elements
* `val` (for value): is used to specify '''containment''' references to other model elements. 
 
A containment reference means that if the container is deleted, then the contained elements are also deleted. Also each model element can have at most one container. For example, if an instance of `Flowchart` is deleted, all `nodes` and `transitions` in it are also deleted (since `nodes` and `transitions` are denoted as `val`). Also, a node cannot be contained in two instances of `Flowchart` simultaneously. On the other hand, if we delete an instance of `Transition`, the nodes that are its `source` and `target` are not deleted automatically (since `source` and `target` are specified as `ref`). Also, a `Node` can be the `source` or the `target` of many `Transition`s.

== Creating the filesystem metamodel in Eclipse ==
 
Now we need to transfer the metamodel above in Eclipse. We create a new project named `flowchartdsl`, and then in it, a new file named `flowchart.emf`. Then we copy-paste the Emfatic specification above and the result looks like this:

[[image:screenshot1.jpg]]

Now we need to convert this textual specification into a proper Ecore metamodel. We can do this by right-clicking on `filesystem.emf` and selecting `Generate Ecore Model`. Once we do this, a `flowchart.ecore` file will appear next to `filesystem.emf`. This is the proper Ecore metamodel stored in XMI (you can see the XMI by right-clicking `flowchart.ecore` and selecting `Open with->Text editor`. 